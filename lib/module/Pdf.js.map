{"version":3,"sources":["Pdf.tsx"],"names":["React","forwardRef","useEffect","useImperativeHandle","useRef","useState","FlatList","StyleSheet","View","PdfUtil","PdfView","separatorSize","useMeasurePages","layoutWidth","pageDims","maxPageHeight","onMeasurePages","measurements","offset","pageSize","itemHeight","Math","min","height","width","push","Pdf","props","ref","onError","onLoadComplete","source","flatListLayout","setFlatListLayout","setPageDims","listRef","scrollToIndex","index","current","animated","scrollToOffset","state","live","getPageSizes","then","sizes","length","catch","error","shrinkToFit","Number","MAX_VALUE","data","console","warn","bound","i","styles","separator","_item","toString","event","nativeEvent","layout","pageAlign","maxHeight","page","initialScrollIndex","ListEmptyComponent","onMomentumScrollBegin","onMomentumScrollEnd","onScroll","onScrollBeginDrag","onScrollEndDrag","refreshControl","scrollEventThrottle","create","backgroundColor","elevation","shadowColor","shadowOffset","shadowOpacity","shadowRadius","alignItems"],"mappings":"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","sourcesContent":["import React, {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  FlatList,\n  NativeScrollEvent,\n  NativeSyntheticEvent,\n  RefreshControlProps,\n  StyleSheet,\n  View,\n} from 'react-native';\n\nimport { PageDim, PdfUtil } from './PdfUtil';\nimport { PdfView } from './PdfView';\n\nexport type PageMeasurement = {\n  /**\n   * Display height of the page.\n   */\n  itemHeight: number;\n\n  /**\n   * Position (dp) within the FlatList.\n   */\n  offset: number;\n};\n\n/**\n * Optional props, forwarded to the underlying `FlatList` component.\n */\ntype BaseListProps = {\n  /**\n   * Instead of starting at the top with the first item, start at\n   * initialScrollIndex.\n   */\n  initialScrollIndex?: number;\n\n  /**\n   * Rendered when the list is empty. Can be a React Component Class, a render\n   * function, or a rendered element.\n   */\n  ListEmptyComponent?: React.ComponentType<any> | React.ReactElement | null;\n\n  /**\n   * Called when the momentum scroll starts (scroll which occurs as the scroll\n   * view starts gliding).\n   */\n  onMomentumScrollBegin?: (\n    event: NativeSyntheticEvent<NativeScrollEvent>\n  ) => void;\n\n  /**\n   * Called when the momentum scroll ends (scroll which occurs as the scroll\n   * view glides to a stop).\n   */\n  onMomentumScrollEnd?: (\n    event: NativeSyntheticEvent<NativeScrollEvent>\n  ) => void;\n\n  /**\n   * Fires at most once per frame during scrolling. The frequency of the events\n   * can be controlled using the scrollEventThrottle prop.\n   */\n  onScroll?: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;\n\n  /**\n   * Called when the user begins to drag the scroll view.\n   */\n  onScrollBeginDrag?: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;\n\n  /**\n   * Called when the user stops dragging the scroll view and it either stops or\n   * begins to glide.\n   */\n  onScrollEndDrag?: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;\n\n  /**\n   * A RefreshControl component, used to provide pull-to-refresh\n   * functionality for the ScrollView.\n   */\n  refreshControl?: React.ReactElement<RefreshControlProps>;\n\n  /**\n   * This controls how often the scroll event will be fired while scrolling\n   * (in events per seconds). A higher number yields better accuracy for code\n   * that is tracking the scroll position, but can lead to scroll performance\n   * problems due to the volume of information being send over the bridge. The\n   * default value is zero, which means the scroll event will be sent only once\n   * each time the view is scrolled.\n   * Only available on iOS.\n   */\n  scrollEventThrottle?: number;\n};\n\ntype PdfProps = BaseListProps & {\n  /**\n   * Callback to handle errors.\n   */\n  onError?: (error: Error) => void;\n\n  /**\n   * Callback to handle pdf load completion.\n   *\n   * Passed the page count of the loaded pdf.\n   */\n  onLoadComplete?: (numberOfPages: number) => void;\n\n  /**\n   * Callback to receive layout details of all pages.\n   */\n  onMeasurePages?: (measurements: PageMeasurement[]) => void;\n\n  /**\n   * Size pages such that each page can be displayed without cutoff. Applies\n   * when device is in the specified orientation.\n   */\n  shrinkToFit?: 'never' | 'portrait' | 'landscape' | 'always';\n\n  /**\n   * Document to display.\n   */\n  source: string;\n\n  /**\n   * Used to locate this view in end-to-end tests.\n   */\n  testID?: string;\n};\n\nexport type PdfRef = {\n  /**\n   * Scroll to the specified page (0-indexed).\n   */\n  scrollToIndex(index: number): void;\n\n  /**\n   * Scroll to the specified offset.\n   */\n  scrollToOffset(offset: number): void;\n};\n\nconst separatorSize = 8;\n\n/**\n * Report measurements of all pages to a callback.\n */\nfunction useMeasurePages(\n  layoutWidth: number,\n  pageDims: PageDim[],\n  maxPageHeight: number,\n  onMeasurePages?: (measurements: PageMeasurement[]) => void\n) {\n  useEffect(() => {\n    if (onMeasurePages == null || layoutWidth === 0) {\n      return;\n    }\n    const measurements: PageMeasurement[] = [];\n    let offset = 0;\n    for (const pageSize of pageDims) {\n      // Measurements include scaling to fill width,\n      const itemHeight = Math.min(\n        maxPageHeight,\n        (layoutWidth * pageSize.height) / pageSize.width\n      );\n      measurements.push({ itemHeight, offset });\n      // and offset for separator between pages.\n      offset += itemHeight + separatorSize;\n    }\n    onMeasurePages(measurements);\n  }, [layoutWidth, maxPageHeight, onMeasurePages, pageDims]);\n}\n\n/**\n * Display a pdf.\n */\nexport const Pdf = forwardRef((props: PdfProps, ref: React.Ref<PdfRef>) => {\n  const { onError, onLoadComplete, source } = props;\n\n  const [flatListLayout, setFlatListLayout] = useState<PageDim>({\n    height: 0,\n    width: 0,\n  });\n  const [pageDims, setPageDims] = useState<PageDim[]>([]);\n\n  const listRef = useRef<FlatList<PageDim>>(null);\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      scrollToIndex: (index) =>\n        listRef.current?.scrollToIndex({ animated: true, index }),\n      scrollToOffset: (offset) =>\n        listRef.current?.scrollToOffset({ animated: true, offset }),\n    }),\n    [listRef]\n  );\n\n  useEffect(() => {\n    const state = { live: true };\n    PdfUtil.getPageSizes(source)\n      .then((sizes) => {\n        if (state.live) {\n          setPageDims(sizes);\n          if (onLoadComplete != null) {\n            onLoadComplete(sizes.length);\n          }\n        }\n      })\n      .catch((error) => {\n        if (state.live && onError != null) {\n          onError(error);\n        }\n      });\n\n    return () => {\n      state.live = false;\n    };\n  }, [onError, onLoadComplete, setPageDims, source]);\n\n  let maxPageHeight: number | undefined;\n  if (flatListLayout.height > 0) {\n    if (\n      props.shrinkToFit === 'always' ||\n      (flatListLayout.height > flatListLayout.width &&\n        props.shrinkToFit === 'portrait') ||\n      (flatListLayout.height < flatListLayout.width &&\n        props.shrinkToFit === 'landscape')\n    ) {\n      maxPageHeight = flatListLayout.height;\n    }\n  }\n\n  useMeasurePages(\n    flatListLayout.width,\n    pageDims,\n    maxPageHeight ?? Number.MAX_VALUE,\n    props.onMeasurePages\n  );\n\n  return (\n    <FlatList\n      data={flatListLayout.height === 0 ? [] : pageDims}\n      getItemLayout={(data, index) => {\n        // Default height, so layout computation will always return non-zero.\n        // This case should never occur.\n        let itemHeight = 100;\n        let offset = (itemHeight + separatorSize) * index;\n        if (data == null) {\n          console.warn('Pdf list getItemLayout() not passed data.');\n        } else if (flatListLayout.height === 0 || flatListLayout.width === 0) {\n          console.warn(\n            'Pdf list getItemLayout() could not determine screen size.'\n          );\n        } else {\n          const bound = maxPageHeight ?? Number.MAX_VALUE;\n          let pageSize = data[index];\n          itemHeight = Math.min(\n            bound,\n            (flatListLayout.width * pageSize.height) / pageSize.width\n          );\n          // Add up the separators and heights of pages before the current page.\n          offset = 0;\n          for (let i = 0; i < index; ++i) {\n            pageSize = data[i];\n            offset +=\n              separatorSize +\n              Math.min(\n                bound,\n                (flatListLayout.width * pageSize.height) / pageSize.width\n              );\n          }\n        }\n        return {\n          length: itemHeight,\n          offset,\n          index,\n        };\n      }}\n      initialNumToRender={1}\n      ItemSeparatorComponent={() => <View style={styles.separator} />}\n      keyExtractor={(_item, index) => index.toString()}\n      maxToRenderPerBatch={2}\n      onLayout={(event) => {\n        // For sizing pages to fit width, including on device rotation.\n        setFlatListLayout({\n          height: event.nativeEvent.layout.height,\n          width: event.nativeEvent.layout.width,\n        });\n      }}\n      ref={listRef}\n      renderItem={({ index }) => (\n        <View style={[styles.pageAlign, { maxHeight: maxPageHeight }]}>\n          <View>\n            <PdfView page={index} source={source} style={styles.page} />\n          </View>\n        </View>\n      )}\n      windowSize={5}\n      initialScrollIndex={props.initialScrollIndex}\n      ListEmptyComponent={props.ListEmptyComponent}\n      onMomentumScrollBegin={props.onMomentumScrollBegin}\n      onMomentumScrollEnd={props.onMomentumScrollEnd}\n      onScroll={props.onScroll}\n      onScrollBeginDrag={props.onScrollBeginDrag}\n      onScrollEndDrag={props.onScrollEndDrag}\n      refreshControl={props.refreshControl}\n      scrollEventThrottle={props.scrollEventThrottle}\n      testID=\"pdfFlatList\"\n    />\n  );\n});\n\nconst styles = StyleSheet.create({\n  page: {\n    backgroundColor: '#fff',\n    elevation: 4,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.23,\n    shadowRadius: 2.62,\n  },\n  pageAlign: { alignItems: 'center' },\n  separator: { height: separatorSize },\n});\n"]}